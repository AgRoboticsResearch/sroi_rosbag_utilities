#!/usr/bin/env python3
"""
Transform Camera Trajectory Script

This script transforms camera trajectories from ORB-SLAM format to an initial camera frame
with X-forward coordinate system and saves the result with timestamps.

Usage:
    python transform_trajectory.py <folder_path>
    
The script expects to find 'times.txt' and 'CameraTrajectory.txt' in the specified folder.
Output will be saved as 'CameraTrajectoryTransformed.txt' in the same folder.

Author: Generated for SROI ROS Bag Utilities
Date: 2025-07-25
"""

import numpy as np
import os
import sys
import argparse
from pathlib import Path


def load_trajectory_data(folder_path):
    """
    Load trajectory and timestamp data from folder.
    
    Args:
        folder_path (str): Path to folder containing times.txt and CameraTrajectory.txt
        
    Returns:
        tuple: (trajectory_matrices, timestamps)
    """
    time_path = os.path.join(folder_path, "times.txt")
    traj_path = os.path.join(folder_path, "CameraTrajectory.txt")
    
    if not os.path.exists(time_path):
        raise FileNotFoundError(f"times.txt not found in {folder_path}")
    if not os.path.exists(traj_path):
        raise FileNotFoundError(f"CameraTrajectory.txt not found in {folder_path}")
    
    # Load trajectory data and reshape to 4x4 matrices
    traj = np.loadtxt(traj_path, delimiter=" ")
    traj = traj.reshape(-1, 3, 4)
    
    # Append [0 0 0 1] to each 3x4 matrix to make it 4x4
    append_row = np.zeros((traj.shape[0], 1, 4))
    append_row[:, 0, 3] = 1
    traj = np.concatenate((traj, append_row), axis=1)
    
    # Load timestamps
    timestamps = np.loadtxt(time_path, delimiter=" ")
    
    return traj, timestamps


def transform_trajectory(traj):
    """
    Transform trajectory to initial camera frame with X-forward coordinate system.
    
    Args:
        traj (np.ndarray): Input trajectory as 4x4 transformation matrices
        
    Returns:
        np.ndarray: Transformed trajectory matrices
    """
    # Get the initial camera pose as reference frame
    T_world_to_initial_cam = traj[0]  # First pose becomes our reference
    T_initial_cam_to_world = np.linalg.inv(T_world_to_initial_cam)
    
    # Transformation from ORB-SLAM camera frame to X-forward frame
    # ORB-SLAM: X-right, Y-down, Z-forward
    # Target:   X-forward, Y-left, Z-up
    T_init_cam_to_orb = np.array([
        [ 0, 0, 1, 0],  # Target X = ORB Z (forward)
        [-1, 0, 0, 0],  # Target Y = -ORB X (right -> left)
        [ 0,-1, 0, 0],  # Target Z = -ORB Y (down -> up)
        [ 0, 0, 0, 1]
    ])
    
    # Transform all poses to be relative to initial camera frame with new coordinate system
    traj_transformed = np.zeros_like(traj)
    
    for i in range(len(traj)):
        # Current pose in world coordinates (ORB-SLAM frame)
        T_orb_to_traj = traj[i]
        
        # Transform to be relative to initial camera frame (still in ORB coordinates)
        T_init_cam_to_traj = T_init_cam_to_orb @ T_orb_to_traj
        
        traj_transformed[i] = T_init_cam_to_traj
    
    return traj_transformed


def save_transformed_trajectory(traj_transformed, timestamps, output_path):
    """
    Save transformed trajectory with timestamps and proper header.
    
    Args:
        traj_transformed (np.ndarray): Transformed trajectory matrices
        timestamps (np.ndarray): Corresponding timestamps
        output_path (str): Output file path
    """
    # Create header
    header = [
        "# Transformed Camera Trajectory",
        "# Generated by transform_trajectory.py",
        "# Coordinate system: X-forward, Y-left, Z-up relative to initial camera frame",
        "# Format: timestamp r11 r12 r13 tx r21 r22 r23 ty r31 r32 r33 tz",
        "# Where:",
        "#   timestamp: frame timestamp",
        "#   r11 r12 r13 tx: first row of 3x4 transformation matrix",
        "#   r21 r22 r23 ty: second row of 3x4 transformation matrix", 
        "#   r31 r32 r33 tz: third row of 3x4 transformation matrix",
        "#"
    ]
    
    # Convert transformation matrices to timestamp + 3x4 matrix format (same as CameraTrajectory.txt)
    output_data = []
    
    for i in range(len(traj_transformed)):
        # Extract 3x4 transformation matrix (rotation + translation)
        transform_3x4 = traj_transformed[i, :3, :]  # Get first 3 rows (3x4 matrix)
        transform_flat = transform_3x4.flatten()  # Flatten to 12 elements
        
        # Format: timestamp + 12 elements of 3x4 matrix
        line_data = [timestamps[i]] + transform_flat.tolist()
        output_data.append(line_data)
    
    # Save to file
    with open(output_path, 'w') as f:
        # Write header
        for line in header:
            f.write(line + '\n')
        
        # Write data
        for line_data in output_data:
            formatted_line = ' '.join([f'{val:.6f}' for val in line_data])
            f.write(formatted_line + '\n')


def main():
    """Main function to process command line arguments and run transformation."""
    parser = argparse.ArgumentParser(
        description="Transform camera trajectory to initial camera frame with X-forward coordinate system",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python transform_trajectory.py /path/to/data/folder
    python transform_trajectory.py ./postproc/segment_1/
        """
    )
    
    parser.add_argument(
        'folder_path',
        type=str,
        help='Path to folder containing times.txt and CameraTrajectory.txt'
    )
    
    parser.add_argument(
        '--output',
        type=str,
        default=None,
        help='Output file path (default: CameraTrajectoryTransformed.txt in input folder)'
    )
    
    args = parser.parse_args()
    
    # Validate input folder
    folder_path = Path(args.folder_path)
    if not folder_path.exists():
        print(f"Error: Folder '{folder_path}' does not exist")
        sys.exit(1)
    
    if not folder_path.is_dir():
        print(f"Error: '{folder_path}' is not a directory")
        sys.exit(1)
    
    # Set output path
    if args.output:
        output_path = args.output
    else:
        output_path = folder_path / "CameraTrajectoryTransformed.txt"
    
    try:
        print(f"Loading trajectory data from: {folder_path}")
        traj, timestamps = load_trajectory_data(str(folder_path))
        print(f"Loaded {len(traj)} trajectory poses and {len(timestamps)} timestamps")
        
        if len(traj) != len(timestamps):
            print(f"Warning: Number of trajectory poses ({len(traj)}) doesn't match timestamps ({len(timestamps)})")
            min_len = min(len(traj), len(timestamps))
            traj = traj[:min_len]
            timestamps = timestamps[:min_len]
            print(f"Using first {min_len} entries")
        
        print("Transforming trajectory to initial camera frame...")
        traj_transformed = transform_trajectory(traj)
        
        print(f"Saving transformed trajectory to: {output_path}")
        save_transformed_trajectory(traj_transformed, timestamps, str(output_path))
        
        print("Transformation completed successfully!")
        print(f"\nTrajectory Statistics:")
        print(f"Original frame - Position range:")
        print(f"  X: [{traj[:, 0, 3].min():.3f}, {traj[:, 0, 3].max():.3f}]")
        print(f"  Y: [{traj[:, 1, 3].min():.3f}, {traj[:, 1, 3].max():.3f}]") 
        print(f"  Z: [{traj[:, 2, 3].min():.3f}, {traj[:, 2, 3].max():.3f}]")
        print(f"Transformed frame - Position range:")
        print(f"  X: [{traj_transformed[:, 0, 3].min():.3f}, {traj_transformed[:, 0, 3].max():.3f}]")
        print(f"  Y: [{traj_transformed[:, 1, 3].min():.3f}, {traj_transformed[:, 1, 3].max():.3f}]")
        print(f"  Z: [{traj_transformed[:, 2, 3].min():.3f}, {traj_transformed[:, 2, 3].max():.3f}]")
        
    except FileNotFoundError as e:
        print(f"Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Error processing trajectory: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
